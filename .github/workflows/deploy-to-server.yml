name: Deploy to Server

on:
  push:
    branches: [ main, master, 1.0 ]
  workflow_dispatch:
    inputs:
      deployment_type:
        description: 'Type of deployment'
        required: true
        default: 'shared-hosting'
        type: choice
        options:
        - docker
        - shared-hosting
      force_deploy:
        description: 'Force deployment (skip tests)'
        required: false
        default: false
        type: boolean

jobs:
  test:
    runs-on: ubuntu-latest
    if: ${{ !inputs.force_deploy }}
    
    services:
      postgres:
        image: postgres:16
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_USER: postgres
          POSTGRES_DB: horilla_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
    - uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'

    - name: Install system dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y libcairo2-dev gcc

    - name: Install Python dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt

    - name: Set up test environment
      run: |
        cp .env.dist .env
        echo "DEBUG=True" >> .env
        echo "SECRET_KEY=test-secret-key-for-ci" >> .env
        echo "DATABASE_URL=postgres://postgres:postgres@localhost:5432/horilla_test" >> .env
        echo "ALLOWED_HOSTS=localhost,127.0.0.1" >> .env

    - name: Run migrations
      run: |
        python manage.py makemigrations
        python manage.py migrate

    - name: Collect static files
      run: |
        python manage.py collectstatic --noinput

  deploy-shared-hosting:
    needs: [test]
    runs-on: ubuntu-latest
    if: always() && (needs.test.result == 'success' || inputs.force_deploy) && (inputs.deployment_type == 'shared-hosting' || inputs.deployment_type == '')

    steps:
    - uses: actions/checkout@v4

    - name: Create shared hosting deployment package
      run: |
        # Create environment file for shared hosting
        cat > .env.production << EOF
        DEBUG=False
        SECRET_KEY=\${{ secrets.DJANGO_SECRET_KEY || 'change-this-secret-key-in-production' }}
        ALLOWED_HOSTS=\${{ secrets.ALLOWED_HOSTS || '65.20.74.159,localhost,127.0.0.1' }}
        CSRF_TRUSTED_ORIGINS=\${{ secrets.CSRF_TRUSTED_ORIGINS || 'http://65.20.74.159:8002' }}
        TIME_ZONE=UTC
        DB_ENGINE=django.db.backends.sqlite3
        DB_NAME=horilla_production.sqlite3
        EOF
        
        # Create deployment script
        cat > deploy_server.sh << 'EOF'
        #!/bin/bash
        set -e
        
        echo "ðŸš€ Starting Horilla shared hosting deployment..."
        
        # Create application directory
        mkdir -p ~/horilla-app
        cd ~/horilla-app
        
        # Set up Python virtual environment
        python3 -m venv venv || python -m venv venv
        source venv/bin/activate
        
        # Upgrade pip and install dependencies
        pip install --upgrade pip
        pip install -r requirements.txt
        
        # Copy production environment
        cp .env.production .env
        
        # Generate a secure secret key if not provided
        if grep -q "change-this-secret-key-in-production" .env; then
            SECRET_KEY=$(python3 -c "import secrets; print(secrets.token_hex(32))")
            sed -i "s/change-this-secret-key-in-production/django-prod-$SECRET_KEY/" .env
        fi
        
        # Run database migrations
        python manage.py makemigrations
        python manage.py migrate
        
        # Collect static files
        python manage.py collectstatic --noinput
        
        # Create admin user (ignore if exists)
        python manage.py createhorillauser \
          --first_name admin \
          --last_name admin \
          --username admin \
          --password admin \
          --email admin@horilla.com \
          --phone 1234567890 2>/dev/null || echo "Admin user already exists"
        
        # Create systemd service file (optional)
        cat > horilla.service << 'SERVICEEOF'
        [Unit]
        Description=Horilla HR Application
        After=network.target
        
        [Service]
        Type=exec
        User=$(whoami)
        WorkingDirectory=$(pwd)
        Environment=PATH=$(pwd)/venv/bin
        ExecStart=$(pwd)/venv/bin/gunicorn --bind 0.0.0.0:8002 --workers 2 --timeout 60 horilla.wsgi:application
        Restart=always
        
        [Install]
        WantedBy=multi-user.target
        SERVICEEOF
        
        # Create start script
        cat > start_horilla.sh << 'STARTEOF'
        #!/bin/bash
        cd "$(dirname "$0")"
        source venv/bin/activate
        
        # Check if gunicorn is running
        if pgrep -f "gunicorn.*horilla" > /dev/null; then
            echo "Horilla is already running. Stopping it first..."
            pkill -f "gunicorn.*horilla" || true
            sleep 2
        fi
        
        echo "Starting Horilla..."
        nohup gunicorn --bind 0.0.0.0:8002 --workers 2 --timeout 60 horilla.wsgi:application > horilla.log 2>&1 &
        echo "Horilla started! Check horilla.log for output."
        echo "Application should be accessible at http://$(hostname -I | awk '{print $1}'):8002"
        STARTEOF
        
        # Create stop script
        cat > stop_horilla.sh << 'STOPEOF'
        #!/bin/bash
        echo "Stopping Horilla..."
        pkill -f "gunicorn.*horilla" || echo "No Horilla process found"
        echo "Horilla stopped."
        STOPEOF
        
        # Make scripts executable
        chmod +x start_horilla.sh stop_horilla.sh
        
        echo "âœ… Deployment setup completed!"
        echo ""
        echo "ðŸ“ To start Horilla: ./start_horilla.sh"
        echo "ðŸ“ To stop Horilla: ./stop_horilla.sh"
        echo "ðŸ“ View logs: tail -f horilla.log"
        echo ""
        echo "ðŸ”‘ Default login: admin / admin"
        EOF
        
        chmod +x deploy_server.sh

    - name: Transfer files to server
      uses: appleboy/scp-action@v0.1.7
      with:
        host: ${{ secrets.HOST || '65.20.74.159' }}
        username: ${{ secrets.USERNAME || 'milestonehre' }}
        key: ${{ secrets.SSH_PRIVATE_KEY }}
        port: ${{ secrets.PORT || 22 }}
        source: "."
        target: "~/horilla-deployment-temp"
        rm: true

    - name: Deploy on server
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ secrets.HOST || '65.20.74.159' }}
        username: ${{ secrets.USERNAME || 'milestonehre' }}
        key: ${{ secrets.SSH_PRIVATE_KEY }}
        port: ${{ secrets.PORT || 22 }}
        script: |
          set -e
          
          echo "ðŸ“¦ Preparing deployment..."
          
          # Stop any existing Horilla instance
          pkill -f "gunicorn.*horilla" || true
          
          # Backup existing installation if it exists
          if [ -d "~/horilla-app" ]; then
            echo "ðŸ”„ Backing up existing installation..."
            mv ~/horilla-app ~/horilla-app-backup-$(date +%Y%m%d-%H%M%S) || true
          fi
          
          # Move new files to app directory
          mv ~/horilla-deployment-temp ~/horilla-app
          cd ~/horilla-app
          
          # Run deployment script
          bash deploy_server.sh
          
          # Start the application
          ./start_horilla.sh
          
          # Wait a moment and check if it's running
          sleep 5
          if pgrep -f "gunicorn.*horilla" > /dev/null; then
            echo "âœ… Horilla deployed and started successfully!"
            echo "ðŸŒ Application should be accessible at http://65.20.74.159:8002"
          else
            echo "âŒ Failed to start Horilla. Check logs:"
            tail -20 ~/horilla-app/horilla.log || echo "No log file found"
            exit 1
          fi

  deploy-docker:
    needs: [test]
    runs-on: ubuntu-latest
    if: always() && (needs.test.result == 'success' || inputs.force_deploy) && inputs.deployment_type == 'docker'

    steps:
    - uses: actions/checkout@v4

    - name: Create Docker deployment package
      run: |
        # Update docker-compose for production
        cat > docker-compose.prod.yml << EOF
        services:
          server:
            build:
              context: .
              dockerfile: Dockerfile
            ports:
              - "8002:8000"
            restart: unless-stopped
            environment:
              DEBUG: "False"
              SECRET_KEY: "\${{ secrets.DJANGO_SECRET_KEY || 'change-me-in-production' }}"
              DATABASE_URL: "postgres://postgres:postgres@db:5432/horilla"
              ALLOWED_HOSTS: "\${{ secrets.ALLOWED_HOSTS || '65.20.74.159,localhost' }}"
              CSRF_TRUSTED_ORIGINS: "\${{ secrets.CSRF_TRUSTED_ORIGINS || 'http://65.20.74.159:8002' }}"
            command: sh ./entrypoint.sh
            volumes:
              - ./media:/app/media
            depends_on:
              db:
                condition: service_healthy

          db:
            image: postgres:16-bullseye
            environment:
              POSTGRES_DB: horilla
              POSTGRES_USER: postgres
              POSTGRES_PASSWORD: postgres
              POSTGRES_INITDB_ARGS: "--auth-host=scram-sha-256"
              PGDATA: /var/lib/postgresql/data/pgdata
            ports:
              - "5432:5432"
            restart: unless-stopped
            volumes:
              - horilla-data:/var/lib/postgresql/data
            healthcheck:
              test: ["CMD", "pg_isready", "-U", "postgres"]
              interval: 10s
              timeout: 5s
              retries: 5

        volumes:
          horilla-data:
        EOF
        
        # Create Docker deployment script
        cat > deploy_docker.sh << 'EOF'
        #!/bin/bash
        set -e
        
        echo "ðŸ³ Starting Docker deployment..."
        
        # Install Docker if not present
        if ! command -v docker &> /dev/null; then
            echo "ðŸ“¦ Installing Docker..."
            curl -fsSL https://get.docker.com -o get-docker.sh
            sudo sh get-docker.sh
            sudo usermod -aG docker $USER
            echo "âš ï¸  Please log out and back in to use Docker without sudo"
        fi
        
        # Stop existing containers
        docker compose -f docker-compose.prod.yml down || true
        
        # Remove old images
        docker system prune -f
        
        # Build and start containers
        docker compose -f docker-compose.prod.yml up --build -d
        
        # Wait for services to be ready
        echo "â³ Waiting for services to start..."
        sleep 30
        
        # Check status
        docker compose -f docker-compose.prod.yml ps
        
        echo "âœ… Docker deployment completed!"
        echo "ðŸŒ Application should be accessible at http://$(hostname -I | awk '{print $1}'):8002"
        EOF
        
        chmod +x deploy_docker.sh

    - name: Transfer Docker files to server
      uses: appleboy/scp-action@v0.1.7
      with:
        host: ${{ secrets.HOST }}
        username: ${{ secrets.USERNAME }}
        key: ${{ secrets.SSH_PRIVATE_KEY }}
        port: ${{ secrets.PORT || 22 }}
        source: "."
        target: "~/horilla-docker-deployment"
        rm: true

    - name: Deploy with Docker
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ secrets.HOST }}
        username: ${{ secrets.USERNAME }}
        key: ${{ secrets.SSH_PRIVATE_KEY }}
        port: ${{ secrets.PORT || 22 }}
        script: |
          cd ~/horilla-docker-deployment
          bash deploy_docker.sh

  notify:
    needs: [deploy-shared-hosting, deploy-docker]
    runs-on: ubuntu-latest
    if: always()

    steps:
    - name: Deployment Summary
      run: |
        echo "## ðŸš€ Deployment Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "- **Repository**: ${{ github.repository }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Branch**: ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Commit**: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Deployment Type**: ${{ inputs.deployment_type || 'shared-hosting' }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        if [[ "${{ needs.deploy-shared-hosting.result }}" == "success" ]]; then
          echo "âœ… **Shared Hosting Deployment**: SUCCESS" >> $GITHUB_STEP_SUMMARY
          echo "ðŸŒ **Access URL**: http://65.20.74.159:8002" >> $GITHUB_STEP_SUMMARY
        elif [[ "${{ needs.deploy-docker.result }}" == "success" ]]; then
          echo "âœ… **Docker Deployment**: SUCCESS" >> $GITHUB_STEP_SUMMARY
          echo "ðŸŒ **Access URL**: http://65.20.74.159:8002" >> $GITHUB_STEP_SUMMARY
        else
          echo "âŒ **Deployment**: FAILED" >> $GITHUB_STEP_SUMMARY
        fi
        
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "ðŸ”‘ **Default Login**: admin / admin" >> $GITHUB_STEP_SUMMARY
